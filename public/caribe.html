<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="caribe.css"> </link>
<link rel="stylesheet" type="text/css" href="lib/bootstrap.min.css"> </link>
<link rel="stylesheet" type="text/css" href="lib/bootstrap-theme.min.css"> </link>
<body>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <a class="navbar-brand" href="#">Petrocaribe: A Comedy of Errors</a>
      </div>
    </div>
  </nav>
  <div class="row">
    <div class="col-sm-3">
      <div class="panel panel-default">
        <div class="panel-heading">Introduction</div>
        <div class="panel-body">
          <b>Petrocaribe</b> is an oil alliance of many Caribbean states with Venezuela to purchase oil on conditions of preferential payment. The alliance was launched on 29 June 2005 in Puerto La Cruz, Venezuela. In 2013 Petrocaribe agreed links with the Bolivarian Alliance for the Americas (ALBA), to go beyond oil and promote economic cooperation.
        </div>
      </div>
    </div>
    <div class="col-sm-9">
      <div class="panel panel-default">
        <div class="panel-heading">Petrocaribe Countries</div>
        <div id="map">
        </div>
      </div>
    </div>
  </div>
  <script src="lib/d3.v3.min.js" charset="utf-8"></script>
  <script src="lib/topojson.v1.min.js"></script>
  <script src="lib/bootstrap.min.js" charset="utf-8"></script>
  <script type="text/javascript">
    var margin = {top: 0, left: 0, bottom: 0, right: 0}
      , width = parseInt(d3.select('#map').style('width'))
      , width = width - margin.left - margin.right
      , mapRatio = .7
      , height = width * mapRatio;

    var svg = d3.select("#map").append("svg")
    		.attr("width", width)
        .attr("height", height)
				.attr("class", "root");

    var hiddenCountries = ['COL', 'BRA', 'PRI', 'FRA', 'MEX', 'BRB', 'SLV',
		                       'USA', 'ECU', 'PER', 'PAN', 'CRI', 'TTO'];
    function isHiddenCountry(c) {
			return hiddenCountries.indexOf(c) >= 0;
		}

		var projection = d3.geo.mercator()
			.center([-73, 14])
			.scale(width * 4 / 3)
			.translate([width / 2, height / 2]);

  	var path = d3.geo.path()
  		.projection(projection);

    var radius = d3.scale.sqrt()
      .domain([0, 200])
      .range([0, 60]);

    var voronoi = d3.geom.voronoi()
      .x(function(d) { return path.centroid(d)[0]; })
      .y(function(d) { return path.centroid(d)[1]; })
      .clipExtent([[0, 0], [width, height]]);

  	d3.json("caribe.json", function(error, caribe) {
      if (error) return console.error(error);

  		console.log(caribe);

      var countries = topojson.feature(caribe, caribe.objects.countries);

    	svg.selectAll(".country")
    			.data(countries.features)
  		  .enter().append("path")
    			.attr("class", function(d) { return "country " + d.id; })
    			.attr("d", path)
					.classed("ghost", function(d) { return isHiddenCountry(d.id); });

			svg.append("path")
				.datum(topojson.mesh(caribe, caribe.objects.countries, function(a, b) {
					return a !== b && !(isHiddenCountry(a.id) && isHiddenCountry(b.id));
				}))
				.attr("d", path)
				.attr("class", "border");

			svg.append("path")
					.datum(topojson.mesh(caribe, caribe.objects.countries, function(a, b) {
						return a === b && isHiddenCountry(a.id)
							|| a !== b && isHiddenCountry(a.id) && isHiddenCountry(b.id);
					}))
					.attr("d", path)
					.attr("class", "border ghost");

      var bubble = svg.append("g")
        .attr("class", "bubble")
      .selectAll("circle")
        .data(countries.features
          .sort(function(a, b) { return b.properties.quotaKbd - a.properties.quotaKbd; }))
      .enter();
      bubble.append("circle")
        .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
        .attr("r", function(d) { return radius(d.properties.quotaKbd); })
        .attr("class", function(d){ return "quota " + d.id; });
      bubble.append("circle")
        .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
        .attr("r", function(d) { return radius(d.properties.consumptionKbd); })
        .attr("class", function(d){ return "consumption " + d.id; });

  		svg.selectAll(".country-label")
  				.data(countries.features.filter(function(d) {
            return !isHiddenCountry(d.id);
          }))
			.enter().append("text")
				.attr("class", function(d) { return "country-label " + d.id; })
				.attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; })
				.attr("dy", ".35em")
        .attr("font-size", 12)
				.text(function(d) { return d.properties.name; })
				.style("text-anchor", function(d) {
					return ['KNA', 'VCT', 'DMA'].indexOf(d.id) >= 0 ? "end" :
								['ATG', 'DOM', 'BLZ', 'LCA', 'GRD'].indexOf(d.id) >= 0 ? "start" : "middle";
				});

        //Initiate a group element to place the voronoi diagram in
        var voronoiGroup = svg.append("g")
          .attr("class", "voronoiWrapper");
        console.log(countries.features);
        voronoiGroup.selectAll("path")
            .data(voronoi(countries.features.filter(function(d) {
              return !isHiddenCountry(d.id);
            }))) //Use vononoi() with your dataset inside
          .enter().append("path")
            .attr("d", function(d, i) { console.log(d);return "M" + d.join("L") + "Z"; })
          .attr("class", function(d,i) { return "voronoi " + d.id; }) //Give each cell a unique class where the unique part corresponds to the circle classes
            //.style("stroke", "#2074A0") //I use this to look at how the cells are dispersed as a check
            .style("fill", "none")
            .style("stroke-width", "1px")
            .style("pointer-events", "all")
            .on("mouseover", mouseover)
            .on("mouseout", mouseout)
            .on("touchstart", touchstart);

        d3.select(window).on('resize', resize);

        function resize() {
            // adjust things when the window size changes
            width = parseInt(d3.select('#map').style('width'));
            width = width - margin.left - margin.right;
            height = width * mapRatio;

            // update projection
            projection
                .translate([width / 2, height / 2])
                .scale(width * 4 / 3);

            // resize the map container
            svg.attr('width', width).attr('height', height);

            // resize the map
            svg.selectAll('.country').attr('d', path);
            svg.selectAll('.border').attr('d', path);
            svg.selectAll(".country-label")
              .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; });
            svg.selectAll(".quota")
              .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; });
            svg.selectAll(".consumption")
              .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; });

            voronoi
              .x(function(d) { return path.centroid(d)[0]; })
              .y(function(d) { return path.centroid(d)[1]; })
              .clipExtent([[0, 0], [width, height]]);

              svg.selectAll(".voronoi")
                  .data(voronoi(countries.features.filter(function(d) {
                    return !isHiddenCountry(d.id);
                  })))
                  .attr("d", function(d, i) { console.log(d);return "M" + d.join("L") + "Z"; });

        }
		});

    function mouseover(d,i) {
      d3.selectAll("."+d.point.id).classed("highlighted",true);
    }

    function mouseout(d,i) {
      d3.selectAll("."+d.point.id).classed("highlighted",false);
    }

    function touchstart(d,i) {
      d3.selectAll(".highlighted").classed("highlighted",false);
      mouseover(d,i);
    }

    //////////////////////////////////////////////////////////////
    //////////////////////// Auto Resize /////////////////////////
    //////////////////////////////////////////////////////////////

    </script>
</body>
